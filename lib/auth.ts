const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'https://alphaapi-et-transitpax.azurewebsites.net/api';

export interface LoginResponse {
  token: string;
  refreshToken: string;
  tokenExpiresAt: string;
  user: User;
}

export interface User {
  id: number;
  employeeId: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  station: {
    id: number;
    code: string;
    name: string;
  };
}

export interface Station {
  id: number;
  code: string;
  name: string;
  city: string;
  country: string;
  isActive: boolean;
  createdAt: string;
}

export interface Role {
  id: number;
  name: string;
  description: string;
  isAdmin: boolean;
  isActive: boolean;
  createdAt: string;
  permissions?: Permission[];
}

export interface Permission {
  id: number;
  name: string;
  description: string;
  category: string;
  isAutoGenerated: boolean;
}

// Token storage keys
const TOKEN_KEY = 'exitcheck_token';
const REFRESH_TOKEN_KEY = 'exitcheck_refreshToken';
const USER_KEY = 'exitcheck_user';
const TOKEN_EXPIRES_AT_KEY = 'exitcheck_tokenExpiresAt';

// Token management
export const auth = {
  setAuth: (data: LoginResponse) => {
    if (typeof window !== 'undefined') {
      localStorage.setItem(TOKEN_KEY, data.token);
      localStorage.setItem(REFRESH_TOKEN_KEY, data.refreshToken);
      localStorage.setItem(TOKEN_EXPIRES_AT_KEY, data.tokenExpiresAt);
      localStorage.setItem(USER_KEY, JSON.stringify(data.user));
    }
  },

  getToken: (): string | null => {
    if (typeof window === 'undefined') return null;
    return localStorage.getItem(TOKEN_KEY);
  },

  getRefreshToken: (): string | null => {
    if (typeof window === 'undefined') return null;
    return localStorage.getItem(REFRESH_TOKEN_KEY);
  },

  getUser: (): LoginResponse['user'] | null => {
    if (typeof window === 'undefined') return null;
    const userStr = localStorage.getItem(USER_KEY);
    return userStr ? JSON.parse(userStr) : null;
  },

  isTokenExpired: (): boolean => {
    if (typeof window === 'undefined') return true;
    const expiresAt = localStorage.getItem(TOKEN_EXPIRES_AT_KEY);
    if (!expiresAt) return true;
    
    const expiryTime = new Date(expiresAt).getTime();
    const now = new Date().getTime();
    const fiveMinutes = 5 * 60 * 1000;
    
    return (expiryTime - now) < fiveMinutes;
  },

  clearAuth: () => {
    if (typeof window !== 'undefined') {
      localStorage.removeItem(TOKEN_KEY);
      localStorage.removeItem(REFRESH_TOKEN_KEY);
      localStorage.removeItem(USER_KEY);
      localStorage.removeItem(TOKEN_EXPIRES_AT_KEY);
    }
  },

  isAuthenticated: (): boolean => {
    if (typeof window === 'undefined') return false;
    const token = localStorage.getItem(TOKEN_KEY);
    return !!token && !auth.isTokenExpired();
  },
};

// API call wrapper with automatic token handling
export async function apiCall(
  endpoint: string,
  options: RequestInit = {}
): Promise<Response> {
  const url = `${API_BASE_URL}${endpoint}`;
  const token = auth.getToken();

  // Check if token is expired and refresh if needed
  if (token && auth.isTokenExpired()) {
    try {
      const refreshToken = auth.getRefreshToken();
      if (refreshToken) {
        const refreshResponse = await fetch(`${API_BASE_URL}/Auth/refresh`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ refreshToken }),
        });

        if (refreshResponse.ok) {
          const refreshData: LoginResponse = await refreshResponse.json();
          auth.setAuth(refreshData);
        } else {
          auth.clearAuth();
          if (typeof window !== 'undefined') {
            window.location.href = '/login';
          }
          throw new Error('Token refresh failed');
        }
      }
    } catch (error) {
      auth.clearAuth();
      if (typeof window !== 'undefined') {
        window.location.href = '/login';
      }
      throw error;
    }
  }

  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
    ...(options.headers as Record<string, string> || {}),
  };

  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  // Remove Content-Type for FormData
  if (options.body instanceof FormData) {
    delete headers['Content-Type'];
  }

  const response = await fetch(url, {
    ...options,
    headers,
  });

  if (response.status === 401) {
    auth.clearAuth();
    if (typeof window !== 'undefined') {
      window.location.href = '/login';
    }
    throw new Error('Unauthorized');
  }

  return response;
}

// Auth API
export const authAPI = {
  login: async (employeeId: string, password: string): Promise<LoginResponse> => {
    const response = await apiCall('/Auth/login', {
      method: 'POST',
      body: JSON.stringify({ employeeId, password }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Login failed' }));
      throw new Error(error.error || 'Login failed');
    }

    const data: LoginResponse = await response.json();
    auth.setAuth(data);
    return data;
  },

  refresh: async (refreshToken: string): Promise<LoginResponse> => {
    const response = await fetch(`${API_BASE_URL}/Auth/refresh`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken }),
    });

    if (!response.ok) {
      throw new Error('Token refresh failed');
    }

    const data: LoginResponse = await response.json();
    auth.setAuth(data);
    return data;
  },

  changePassword: async (currentPassword: string, newPassword: string): Promise<{ message: string }> => {
    const response = await apiCall('/Auth/change-password', {
      method: 'POST',
      body: JSON.stringify({ currentPassword, newPassword }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Password change failed' }));
      throw new Error(error.error || 'Password change failed');
    }

    return response.json();
  },

  forgotPassword: async (employeeId: string, email: string): Promise<{ message: string }> => {
    const response = await apiCall('/Auth/forgot-password', {
      method: 'POST',
      body: JSON.stringify({ employeeId, email }),
    });

    return response.json();
  },

  resetPassword: async (employeeId: string, token: string, newPassword: string): Promise<{ message: string }> => {
    const response = await apiCall('/Auth/reset-password', {
      method: 'POST',
      body: JSON.stringify({ employeeId, token, newPassword }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Password reset failed' }));
      throw new Error(error.error || 'Password reset failed');
    }

    return response.json();
  },

  testAuth: async (): Promise<unknown> => {
    const response = await apiCall('/Auth/test-auth', {
      method: 'GET',
    });

    if (!response.ok) {
      throw new Error('Authentication test failed');
    }

    return response.json();
  },
};

// User API
export const userAPI = {
  getAll: async (): Promise<any[]> => {
    const response = await apiCall('/User', { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch users');
    return response.json();
  },

  getById: async (id: number): Promise<any> => {
    const response = await apiCall(`/User/${id}`, { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch user');
    return response.json();
  },

  getMe: async (): Promise<any> => {
    const response = await apiCall('/User/me', { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch current user');
    return response.json();
  },

  create: async (data: {
    employeeId: string;
    email: string;
    password: string;
    firstName: string;
    lastName: string;
    stationId: number;
    roleId: number;
  }): Promise<any> => {
    const response = await apiCall('/User', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to create user' }));
      throw new Error(error.error || 'Failed to create user');
    }
    return response.json();
  },

  update: async (id: number, data: {
    email: string;
    firstName: string;
    lastName: string;
    stationId: number;
    roleId: number;
    isActive: boolean;
  }): Promise<any> => {
    const response = await apiCall(`/User/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to update user' }));
      throw new Error(error.error || 'Failed to update user');
    }
    return response.json();
  },

  delete: async (id: number): Promise<{ message: string }> => {
    const response = await apiCall(`/User/${id}`, { method: 'DELETE' });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to delete user' }));
      throw new Error(error.error || 'Failed to delete user');
    }
    return response.json();
  },
};

// Station API
export const stationAPI = {
  getAll: async (): Promise<Station[]> => {
    const response = await apiCall('/Station', { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch stations');
    return response.json();
  },

  getById: async (id: number): Promise<Station> => {
    const response = await apiCall(`/Station/${id}`, { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch station');
    return response.json();
  },

  create: async (data: {
    code: string;
    name: string;
    city: string;
    country: string;
  }): Promise<Station> => {
    const response = await apiCall('/Station', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to create station' }));
      throw new Error(error.error || 'Failed to create station');
    }
    return response.json();
  },

  update: async (id: number, data: {
    code: string;
    name: string;
    city: string;
    country: string;
  }): Promise<Station> => {
    const response = await apiCall(`/Station/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to update station' }));
      throw new Error(error.error || 'Failed to update station');
    }
    return response.json();
  },

  delete: async (id: number): Promise<{ message: string }> => {
    const response = await apiCall(`/Station/${id}`, { method: 'DELETE' });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to delete station' }));
      throw new Error(error.error || 'Failed to delete station');
    }
    return response.json();
  },
};

// Role API
export const roleAPI = {
  getAll: async (): Promise<Role[]> => {
    const response = await apiCall('/Role', { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch roles');
    return response.json();
  },

  getById: async (id: number): Promise<Role> => {
    const response = await apiCall(`/Role/${id}`, { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch role');
    return response.json();
  },

  getClaims: async (): Promise<Permission[]> => {
    const response = await apiCall('/Role/claims', { method: 'GET' });
    if (!response.ok) throw new Error('Failed to fetch permissions');
    return response.json();
  },

  create: async (data: {
    name: string;
    description: string;
    isAdmin: boolean;
  }): Promise<Role> => {
    const response = await apiCall('/Role', {
      method: 'POST',
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to create role' }));
      throw new Error(error.error || 'Failed to create role');
    }
    return response.json();
  },

  update: async (id: number, data: {
    name: string;
    description: string;
    isAdmin: boolean;
  }): Promise<Role> => {
    const response = await apiCall(`/Role/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to update role' }));
      throw new Error(error.error || 'Failed to update role');
    }
    return response.json();
  },

  assignPermissions: async (roleId: number, permissionIds: number[]): Promise<{ message: string }> => {
    const response = await apiCall(`/Role/${roleId}/permissions`, {
      method: 'POST',
      body: JSON.stringify(permissionIds),
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to assign permissions' }));
      throw new Error(error.error || 'Failed to assign permissions');
    }
    return response.json();
  },

  delete: async (id: number): Promise<{ message: string }> => {
    const response = await apiCall(`/Role/${id}`, { method: 'DELETE' });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Failed to delete role' }));
      throw new Error(error.error || 'Failed to delete role');
    }
    return response.json();
  },
};

