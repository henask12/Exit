/**
 * Cookie-based (HttpOnly) auth (Best practice):
 * - Tokens are NEVER stored in localStorage/sessionStorage.
 * - Login sets HttpOnly cookies via /api/auth/login.
 * - Logout clears HttpOnly cookies via /api/auth/logout.
 * - Current user is read via /api/auth/me (server reads cookie).
 * - All backend API calls go through /api/proxy/* which attaches Authorization
 *   using the HttpOnly access-token cookie and auto-refreshes on 401.
 */

export interface User {
  id: number;
  employeeId: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  station: {
    id: number;
    code: string;
    name: string;
  };
}

export interface LoginResponse {
  token: string;
  refreshToken: string;
  tokenExpiresAt: string;
  user: User;
}

export interface Station {
  id: number;
  code: string;
  name: string;
  city: string;
  country: string;
  isActive: boolean;
  createdAt: string;
}

export interface Role {
  id: number;
  name: string;
  description: string;
  isAdmin: boolean;
  isActive: boolean;
  createdAt: string;
  permissions?: Permission[];
}

export interface Permission {
  id: number;
  name: string;
  description: string;
  category: string;
  isAutoGenerated: boolean;
}

export const auth = {
  /**
   * Returns the current user by calling GET /api/auth/me.
   * This reads the HttpOnly session cookie server-side (JS never sees tokens).
   */
  getUser: async (): Promise<User | null> => {
    try {
      const res = await fetch('/api/auth/me', { credentials: 'include', cache: 'no-store' });
      if (!res.ok) return null;
      const data = await res.json().catch(() => null);
      return (data?.user as User) || null;
    } catch {
      return null;
    }
  },

  /**
   * Clears HttpOnly cookies via POST /api/auth/logout
   */
  clearAuth: async (): Promise<void> => {
    try {
      await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
    } catch {
      // ignore
    }
  },
};

/**
 * API call wrapper:
 * - Calls /api/proxy{endpoint} so the server can attach Authorization from HttpOnly cookie.
 * - /api/proxy will auto-refresh if access token expired.
 */
export async function apiCall(endpoint: string, options: RequestInit = {}): Promise<Response> {
  const headers: Record<string, string> = {
    ...(options.headers as Record<string, string> | undefined),
  };

  // Set JSON content type by default unless sending FormData
  if (!(options.body instanceof FormData) && !headers['Content-Type']) {
    headers['Content-Type'] = 'application/json';
  }

  const res = await fetch(`/api/proxy${endpoint}`, {
    ...options,
    headers,
    credentials: 'include',
    cache: 'no-store',
  });

  if (res.status === 401) {
    await auth.clearAuth();
    if (typeof window !== 'undefined') {
      window.location.href = '/login';
    }
    throw new Error('Unauthorized');
  }

  return res;
}

export const authAPI = {
  /**
   * Logs in via BFF route and sets HttpOnly cookies.
   */
  login: async (employeeId: string, password: string): Promise<User> => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ employeeId, password }),
    });

    const data = await res.json().catch(() => null);
    if (!res.ok) {
      throw new Error(data?.error || 'Login failed');
    }
    return data.user as User;
  },

  logout: async (): Promise<void> => {
    await auth.clearAuth();
  },
};

// ---- Entity APIs (used by React Query hooks) ----

async function jsonOrThrow<T>(res: Response): Promise<T> {
  if (!res.ok) {
    const err = await res.json().catch(() => ({ error: 'Request failed' }));
    throw new Error(err?.error || err?.message || 'Request failed');
  }
  return res.json();
}

export const stationAPI = {
  getAll: async () => jsonOrThrow<Station[]>(await apiCall('/Station')),
  getById: async (id: number) => jsonOrThrow<Station>(await apiCall(`/Station/${id}`)),
  create: async (data: Partial<Station>) =>
    jsonOrThrow<Station>(
      await apiCall('/Station', { method: 'POST', body: JSON.stringify(data) })
    ),
  update: async (id: number, data: Partial<Station>) =>
    jsonOrThrow<Station>(
      await apiCall(`/Station/${id}`, { method: 'PUT', body: JSON.stringify(data) })
    ),
  delete: async (id: number) =>
    jsonOrThrow<{ ok: boolean }>(await apiCall(`/Station/${id}`, { method: 'DELETE' })),
};

export const userAPI = {
  getAll: async () => jsonOrThrow<any[]>(await apiCall('/User')),
  getById: async (id: number) => jsonOrThrow<any>(await apiCall(`/User/${id}`)),
  create: async (data: any) => jsonOrThrow<any>(await apiCall('/User', { method: 'POST', body: JSON.stringify(data) })),
  update: async (id: number, data: any) =>
    jsonOrThrow<any>(await apiCall(`/User/${id}`, { method: 'PUT', body: JSON.stringify(data) })),
  delete: async (id: number) =>
    jsonOrThrow<{ ok: boolean }>(await apiCall(`/User/${id}`, { method: 'DELETE' })),
};

export const roleAPI = {
  getAll: async () => jsonOrThrow<Role[]>(await apiCall('/Role')),
  getById: async (id: number) => jsonOrThrow<Role>(await apiCall(`/Role/${id}`)),
  getClaims: async () => jsonOrThrow<Permission[]>(await apiCall('/Role/claims')),
  create: async (data: Partial<Role>) =>
    jsonOrThrow<Role>(await apiCall('/Role', { method: 'POST', body: JSON.stringify(data) })),
  update: async (id: number, data: Partial<Role>) =>
    jsonOrThrow<Role>(await apiCall(`/Role/${id}`, { method: 'PUT', body: JSON.stringify(data) })),
  assignPermissions: async (roleId: number, permissionIds: number[]) =>
    jsonOrThrow<any>(
      await apiCall(`/Role/${roleId}/permissions`, {
        method: 'POST',
        body: JSON.stringify({ permissionIds }),
      })
    ),
  delete: async (id: number) =>
    jsonOrThrow<{ ok: boolean }>(await apiCall(`/Role/${id}`, { method: 'DELETE' })),
};


